<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Meteor Shower</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>

	<body>
		<div id="percent" style="width:100%; height: 30px; text-align: center">
		</div>

        <div><canvas id="mainCanvas"></canvas></div>
		<script src="js/jquery.js"></script>
		<script src="./js/libs/Tween.js"></script>

		<script src="js/libs/three.js"></script>
		<script src="js/libs/inflate.min.js"></script>
		<script src="js/libs/FBXLoader.js"></script>
		<script src="js/libs/OrbitControls.js"></script>
		<script src="js/libs/Detector.js"></script>
        <script src="js/libs/System.min.js"></script>
		<script src="js/libs/hammer.min.js"></script>
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            //console.info(System);
			var controls;
			var camera, scene, renderer, light;
			var gSphere = new THREE.Object3D();
			var clock = new THREE.Clock();
            var isUserInteracting = false,
                onMouseDownMouseX = 0, onMouseDownMouseY = 0,
                lon = 0, onMouseDownLon = 0,
                lat = 0, onMouseDownLat = 0,
                phi = 0, theta = 0;

			var mixers = [];

            var inputEventState={
                bTouch:false,//默认鼠标控制
                inputPosList:[],
				inputPosNum:0
            }
			var sphereR=[];
			init();
			animate();

			function init() {
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500000 );
				camera.position.set( 0, 0, 0); // 25000

//				controls = new THREE.OrbitControls( camera );
//				controls.target.set( 0, 0, -500000);
//				controls.update();

				scene = new THREE.Scene();
//				scene.background = new THREE.Color( 0xa0a0a0 );
				scene.add(gSphere);

                var ambientLight = new THREE.AmbientLight( 0xffffff, 2);
                scene.add( ambientLight );

//				light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
//				light.position.set( 0, 200, 0 );
//				scene.add( light );
//
				light = new THREE.DirectionalLight( 0xffffff, 2 );
				light.position.set( 0, 0, -1 );
//				light.castShadow = true;
//				light.shadow.camera.top = 180;
//				light.shadow.camera.bottom = -100;
//				light.shadow.camera.left = -120;
//				light.shadow.camera.right = 120;
				scene.add( light );

				// ground
//				var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 25000, 25000 ), new THREE.MeshPhongMaterial( { color: 0xFF8F00, depthWrite: false } ) );
//				mesh.position.z = -25000;
//                mesh.material.side = THREE.DoubleSide;
//				scene.add( mesh );
//
//				var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
//				grid.material.opacity = 0.2;
//				grid.material.transparent = true;
//				scene.add( grid );
//
//				new TWEEN.Tween({theta:0}).to({theta: 2*Math.PI}, 4000)
//					.onUpdate(function (argc) {
//						mesh.rotation.x = argc.theta;
//					})
//					.yoyo(true)
//					.repeat(Infinity)
//					.start();

                loadSphereFBX();

//                new TWEEN.Tween({sf:0.01}).to({sf:1.0}, 4000)
//                    .onUpdate(function (argc) {
//                        gSphere.scale.set(argc.sf, argc.sf, argc.sf);
//                    })
//                    .yoyo(true)
//                    .repeat(Infinity)
//                    .start();
//
//
//                new TWEEN.Tween({theta:0}).to({theta:2*Math.PI}, 100000)
//                    .onUpdate(function (argc) {
//                        gSphere.rotation.y = argc.theta;
//                    })
//                    .yoyo(true)
//                    .repeat(Infinity)
//                    .start();

				//renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('mainCanvas'),
                    preserveDrawingBuffer: true,
//                    alpha: true,     //使透明度可以被修改
                    antialias: true      //开启抗锯齿
                });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.shadowMap.enabled = true;
                //renderer.setClearColor(0xffffff, 0);     //将背景设置为透明
				//container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
                //区分一下操作系统
                if(System.os.indexOf("Android")!=-1||System.os.indexOf("Ipad")!=-1||System.os.indexOf("Iphone")!=-1){
                    //inputEventState.bTouch=true;
                    //document.addEventListener( 'touchstart', onPointerStart, { passive: false } );
                    //document.addEventListener( 'touchmove', onPointerMove, { passive: false } );
                    //document.addEventListener( 'touchend', onPointerUp, { passive: false } );
					
					// 插入 meta 标签
					//var oMeta = document.createElement('meta');
					//oMeta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0, user-scalable=no';
					//oMeta.name = 'viewport';
					//document.getElementsByTagName('head')[0].appendChild(oMeta);
					
                }else {
                    inputEventState.bTouch=false;
                    document.addEventListener( 'mousedown', onPointerStart, { passive: false } );
                    document.addEventListener( 'mousemove', onPointerMove, { passive: false } );
                    document.addEventListener( 'mouseup', onPointerUp, { passive: false } );
                    //document.addEventListener( 'wheel', onDocumentMouseWheel, false );
                }
                
		var myElement = document.getElementById('mainCanvas');

		var mc = new Hammer.Manager(myElement);

		// create a pinch and rotate recognizer
		// these require 2 pointers
		var pinch = new Hammer.Pinch();
		var rotate = new Hammer.Rotate();

		// we want to detect both the same time
		pinch.recognizeWith(rotate);

		// add to the Manager
		mc.add([pinch, rotate]);


		mc.on("pinch rotate", function(ev) {
			myElement.textContent += ev.type +" ";
		});

                
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

            //s1 合并s2
			function combineSpere(s1,s2){

				var c1=s1.center,c2=s2.center;
				var r1=s1.radius,r2=s2.radius;
				var dis=c1.distanceTo(c2);
				if(dis<r1||dis<r2){
					if (r1<r2) 	s1.copy(s2);
				}else{
					var direction=new THREE.Vector3().subVectors(c2,c1).normalize();
					s1.center=new THREE.Vector3().addVectors(c1,direction.multiplyScalar((r1+r2+dis)/2-r1));
					s1.radius=(r1+r2+dis)/2;
				}
			}
			// obj必须是Object3D
			function calculateBoundingSphere(obj){
				if (!(obj instanceof THREE.Object3D)) return undefined;
				var bs=new THREE.Sphere(obj.position.clone(),0.0);
				obj.getWorldPosition(bs.center);

				if (obj instanceof THREE.Mesh) {
					if(!obj.geometry.boundingSphere){
						obj.geometry.computeBoundingSphere();
					}
					var matrixWorld = obj.matrixWorld;		
					bs.copy(obj.geometry.boundingSphere);
					bs.applyMatrix4( matrixWorld );

				}else{
					var children = obj.children;
					for ( var i = 0, l = children.length; i < l; i ++ ) {
						var s=calculateBoundingSphere(children[i]);
						if(i==0){
							bs.copy(s);
						}else
							combineSpere(bs,s);
					}
				}
				return bs;
			}
            			
			function ascSort( a, b ) {

				return a - b;

			}
			function animate() {
				if(sphereR.length===3){
				//距离排序一下
					sphereR.sort(ascSort);
					sphereR.push(0);
					camera.far=sphereR[2]+10000;
				}
				//requestAnimationFrame( animate );
                TWEEN.update();
//                controls.update();

                if(isUserInteracting === false) {
                    lon += 0.1;
                    if(lon < 0) {
                        lon += 360;
                    } else if(lon > 360) {
                        lon -= 360;
                    }
                }

                gSphere.rotation.y = THREE.Math.degToRad(-lon);
                gSphere.rotation.x = THREE.Math.degToRad(-lat);

				if ( mixers.length > 0 ) {
					for ( var i = 0; i < mixers.length; i ++ ) {

						mixers[ i ].update( clock.getDelta() );
					}
				}
				renderer.render( scene, camera );

                window.setTimeout( function() { requestAnimationFrame(animate); }, 1000 / 25);
			}
			
			function loadSphereFBX() {
                var onProgress = function ( xhr ) {
                    if ( xhr.lengthComputable ) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        var p = Math.round( percentComplete, 2 );
                        $("#percent").text('Loading ' + p + '%');
                        if(p >= 100) {
                            $("#percent").attr("style","display:none;");
                        }
                    }
                };
                var onError = function ( xhr ) { console.log("liuzx onError " + xhr) };

                var fbx = "";
                fbx = "huancaibejing.FBX";
                new THREE.FBXLoader().load( 'xingkongmianp/' + fbx, function ( object ) {
                    object.mixer = new THREE.AnimationMixer( object );
                    mixers.push( object.mixer );

                    if(object.animations.length > 0) {
                        var action = object.mixer.clipAction( object.animations[ 0 ] );
                        action.play();
                    }
                    object.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            var mat = child.material;
                            mat.side = THREE.DoubleSide;
                        }
                    });
                    gSphere.add( object );
                    var bs=calculateBoundingSphere(object);
                    sphereR.push(bs.radius);
                    bbox(object);
                } , onProgress, onError);

                // ---------------------------------------------------------------------------
                fbx = "yinhe.FBX";
                new THREE.FBXLoader().load( 'xingkongmianp/' + fbx, function ( object ) {
                    object.mixer = new THREE.AnimationMixer( object );
                    mixers.push( object.mixer );

                    if(object.animations.length > 0) {
                        var action = object.mixer.clipAction( object.animations[ 0 ] );
                        action.play();
                    }
                    object.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            var mat = child.material;
                            mat.color.setRGB(1, 1, 1);
                            mat.side = THREE.DoubleSide;
                        }
                    });
                    gSphere.add( object );
                    bbox(object);
                    var bs=calculateBoundingSphere(object);
                    sphereR.push(bs.radius);
                } , onProgress, onError);
                // ---------------------------------------------------------------------------
                fbx = "haipingmian.FBX";
                new THREE.FBXLoader().load( 'xingkongmianp/' + fbx, function ( object ) {
                    object.mixer = new THREE.AnimationMixer( object );
                    mixers.push( object.mixer );
                    if(object.animations.length > 0) {
                        var action = object.mixer.clipAction( object.animations[ 0 ] );
                        action.play();
                    }
                    object.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            var mat = child.material;
                            mat.side = THREE.DoubleSide;
                        }
                    });
                    var bs=calculateBoundingSphere(object);
                    sphereR.push(bs.radius);
                    gSphere.add( object );
                    bbox(object);
                } , onProgress, onError);
            }

            function bbox(object) {
                var bbox = new THREE.Box3().setFromObject(object)
                var mdlen=bbox.max.x-bbox.min.x;
                var mdwid=bbox.max.z-bbox.min.z;
                var mdhei=bbox.max.y-bbox.min.y;
                var x1=bbox.min.x+mdlen/2;
                var y1=bbox.min.y+mdhei/2;
                var z1=bbox.min.z+mdwid/2;
            }


            function onPointerStart(event) {

                isUserInteracting = true;

                var clientX = event.clientX || event.touches[0].clientX;
                var clientY = event.clientY || event.touches[0].clientY;

                onMouseDownMouseX = clientX;
                onMouseDownMouseY = clientY;

                onMouseDownLon = lon;
                onMouseDownLat = lat;
                if(inputEventState.bTouch){
					inputEventState.PosNum=event.touches.length;
					inputEventState.inputPosList=[];
					onMouseDownMouseX=0;onMouseDownMouseY=0;
					for(var i=0;i<inputEventState.PosNum;i++){
						var pos=new THREE.Vector2(event.touches[i].clientX,event.touches[i].clientY);
						if(i<2){
							onMouseDownMouseX+=pos.x;
							onMouseDownMouseY+=pos.y;
						}						
						inputEventState.inputPosList.push(pos);
					} 	
					onMouseDownMouseX=onMouseDownMouseX/inputEventState.PosNum;
					onMouseDownMouseY=onMouseDownMouseY/inputEventState.PosNum;
                }else{
					var pos=new THREE.Vector2(clientX,clientY);
					inputEventState.inputPosList.push(pos);
					inputEventState.PosNum=1;
				}
            }

            function onPointerMove(event) {
                event.preventDefault();
                event.stopPropagation();
                if(isUserInteracting === true) {
                    var clientX = event.clientX || event.touches[0].clientX;
                    var clientY = event.clientY || event.touches[0].clientY;
                    if(inputEventState.bTouch&&inputEventState.PosNum>=2){
						var movePosList=[];
						for(var i=0;i<inputEventState.PosNum;i++){
							var pos=new THREE.Vector2(event.touches[i].clientX,event.touches[i].clientY);			
							movePosList.push(pos);
						} 	
                        clientX=(movePosList[0].x+movePosList[1].x)/2;
                        clientY=(movePosList[0].y+movePosList[1].y)/2;
                        var touchVect=new THREE.Vector2().subVectors(movePosList[1],movePosList[0]);
                        var len=touchVect.length();

                        var lastVect=new THREE.Vector2().subVectors(inputEventState.inputPosList[1],inputEventState.inputPosList[0]);
                        var lastLen=lastVect.length();
                        //放大
                        if(lastLen<len){                            
							if(camera.near<sphereR[1])
								camera.near+=1000;
                            camera.zoom*=1.005;
                            camera.updateProjectionMatrix();
                        }else{
							if(camera.near>1000)
									camera.near-=1000;
                            camera.zoom*=0.995;
                            camera.updateProjectionMatrix();
                        }
                        inputEventState.inputPosList[0].copy(movePosList[0]);
						inputEventState.inputPosList[1].copy(movePosList[1]);
                    }
                    

                    lon = (clientX - onMouseDownMouseX) * 0.2 + onMouseDownLon;
                    lat = (clientY - onMouseDownMouseY) * 0.2 + onMouseDownLat;
//                    if(lat < -80)
//                        lat = -80;
//                    else if(lat > -45)
//                        lat = -45;

                    if(lon < 0) {
                        lon += 360;
                    } else if(lon > 360) {
                        lon -= 360;
                    }
                }
            }

            function onPointerUp(event) {
                isUserInteracting = false;
            }

		</script>

	</body>
</html>
